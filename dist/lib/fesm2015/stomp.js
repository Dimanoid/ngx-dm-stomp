import { BehaviorSubject, Subject } from 'rxjs';

// Converted to typescript by Dmitry Mukhin (https://github.com/Dimanoid)
// Generated by CoffeeScript 1.7.1
/*
   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0
   Copyright (C) 2010-2013 [Jeff Mesnil](http://jmesnil.net/)
   Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)
 */
const Byte = {
    LF: '\x0A',
    NULL: '\x00'
};
const VERSIONS = {
    V1_0: '1.0',
    V1_1: '1.1',
    V1_2: '1.2',
    supportedVersions: '1.1,1.0'
};
// export interface StompMessage {
//     command: string;
//     headers: any;
//     body: string;
//     ack(headers?: any): void;
//     nack(headers?: any): void;
// }
class StompFrame {
    constructor(command, headers, body) {
        this.command = command;
        this.headers = headers != null ? headers : {};
        this.body = body != null ? body : '';
    }
    static marshall(command, headers, body) {
        let frame;
        frame = new StompFrame(command, headers, body);
        return frame.toString() + Byte.NULL;
    }
    static unmarshall(datas) {
        const ref = datas.split(RegExp('' + Byte.NULL + Byte.LF + '*'));
        const results = [];
        for (let i = 0; i < ref.length; i++) {
            const data = ref[i];
            if (data && data.length > 0) {
                results.push(StompFrame.unmarshallSingle(data));
            }
        }
        return results;
    }
    static unmarshallSingle(data) {
        const divider = data.search(RegExp('' + Byte.LF + Byte.LF));
        const headerLines = data.substring(0, divider).split(Byte.LF);
        const command = headerLines.shift();
        const headers = {};
        const trim = (str) => str.replace(/^\s+|\s+$/g, '');
        const ref = headerLines.reverse();
        for (let i = 0; i < ref.length; i++) {
            const line = ref[i];
            const idx = line.indexOf(':');
            headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));
        }
        let body = '';
        const start = divider + 2;
        if (headers['content-length']) {
            const len = parseInt(headers['content-length'], 0);
            body = ('' + data).substring(start, start + len);
        }
        else {
            let chr = null;
            for (let i = start, j = start, ref = data.length; start <= ref ? j < ref : j > ref; i = start <= ref ? ++j : --j) {
                chr = data.charAt(i);
                if (chr === Byte.NULL) {
                    break;
                }
                body += chr;
            }
        }
        return new StompFrame(command, headers, body);
    }
    toString() {
        const lines = [this.command];
        const skipContentLength = !this.headers['content-length'];
        if (skipContentLength) {
            delete this.headers['content-length'];
        }
        for (const name of Object.keys(this.headers)) {
            lines.push('' + name + ':' + this.headers[name]);
        }
        if (this.body && !skipContentLength) {
            lines.push('content-length:' + (this.sizeOfUTF8(this.body)));
        }
        lines.push(Byte.LF + this.body);
        return lines.join(Byte.LF);
    }
    sizeOfUTF8(s) {
        if (s) {
            const match = encodeURI(s).match(/%..|./g);
            return match ? match.length : 0;
        }
        return 0;
    }
}
class StompClient {
    constructor(ws) {
        this.counter = 0;
        this.connected = false;
        this.heartbeat = {
            outgoing: 10000,
            incoming: 10000
        };
        this.maxWebSocketFrameSize = 16 * 1024;
        this.subscriptions = {};
        this.headers = {};
        this.serverActivity = 0;
        this.ws = ws;
        this.ws.binaryType = 'arraybuffer';
    }
    D(...args) {
        if (this.debug) {
            this.debug(...args);
        }
    }
    now() {
        if (Date.now) {
            return Date.now();
        }
        else {
            return new Date().valueOf();
        }
    }
    _transmit(command, headers, body) {
        let out = StompFrame.marshall(command, headers, body);
        this.D('>>> ', out);
        while (true) {
            if (out.length > this.maxWebSocketFrameSize) {
                this.ws.send(out.substring(0, this.maxWebSocketFrameSize));
                out = out.substring(this.maxWebSocketFrameSize);
                this.D('remaining = ', out.length);
            }
            else {
                return this.ws.send(out);
            }
        }
    }
    _setupHeartbeat(headers) {
        if (headers.version !== VERSIONS.V1_1 && headers.version !== VERSIONS.V1_2) {
            return;
        }
        const hb = headers['heart-beat'].split(',');
        const serverOutgoing = hb[0];
        const serverIncoming = hb[1];
        if (this.heartbeat.outgoing !== 0 && +serverIncoming !== 0) {
            const ttl = Math.max(this.heartbeat.outgoing, +serverIncoming);
            this.D('send PING every ', ttl, 'ms');
            this.pinger = setInterval(() => {
                this.ws.send(Byte.LF);
                this.D('>>> PING');
            }, ttl);
        }
        if (this.heartbeat.incoming !== 0 && +serverOutgoing !== 0) {
            const ttl = Math.max(this.heartbeat.incoming, +serverOutgoing);
            this.D('check PONG every ', ttl, 'ms');
            this.ponger = setInterval(() => {
                const delta = this.now() - this.serverActivity;
                if (delta > ttl * 2) {
                    this.D('did not receive server activity for the last', delta, 'ms');
                    this.ws.close();
                }
            }, ttl);
        }
    }
    connect(login, passcode, host) {
        this.headers['login'] = login;
        this.headers['passcode'] = passcode;
        this.headers['host'] = host;
        this.D('Opening Web Socket...');
        this.ws.onmessage = (evt) => {
            let data;
            if (typeof ArrayBuffer !== 'undefined' && evt.data instanceof ArrayBuffer) {
                const arr = new Uint8Array(evt.data);
                this.D('--- got data length:', arr.length);
                data = '';
                for (let i = 0; i < arr.length; i++) {
                    data = data + String.fromCharCode(arr[i]);
                }
            }
            else {
                data = evt.data;
            }
            this.serverActivity = this.now();
            if (data === Byte.LF) {
                this.D('<<< PONG');
                return;
            }
            this.D('<<< ' + data);
            const umData = StompFrame.unmarshall(data);
            for (let i = 0; i < umData.length; i++) {
                const frame = umData[i];
                switch (frame.command) {
                    case 'CONNECTED':
                        this.D('connected to server ', frame.headers.server);
                        this.connected = true;
                        this._setupHeartbeat(frame.headers);
                        if (this.connectCallback) {
                            this.connectCallback(frame);
                        }
                        break;
                    case 'MESSAGE':
                        const subscription = frame.headers.subscription;
                        const onreceive = this.subscriptions[subscription] || this.onreceive;
                        if (onreceive) {
                            const messageID = frame.headers['message-id'];
                            frame.ack = (headers) => {
                                if (headers == null) {
                                    headers = {};
                                }
                                this.ack(messageID, subscription, headers);
                            };
                            frame.nack = (headers) => {
                                if (headers == null) {
                                    headers = {};
                                }
                                return this.nack(messageID, subscription, headers);
                            };
                            onreceive(frame);
                        }
                        else {
                            this.D('Unhandled received MESSAGE:', frame);
                        }
                        break;
                    case 'RECEIPT':
                        if (this.onreceipt) {
                            this.onreceipt(frame);
                        }
                        break;
                    case 'ERROR':
                        this.D('ws.readyState:', this.ws.readyState);
                        if (this.errorCallback) {
                            this.errorCallback(frame);
                            this.D('after errorCallback ws.readyState:', this.ws.readyState);
                        }
                        break;
                    default:
                        this.D('Unhandled frame:', frame);
                }
                this.D('after switch ws.readyState:', this.ws.readyState);
            }
            this.D('after for ws.readyState:', this.ws.readyState);
        };
        this.ws.onclose = (...q) => {
            this.D('ws.onclose, ws.readyState:', this.ws.readyState, q);
            this._cleanUp();
            if (this.disconnectCallback) {
                this.disconnectCallback();
            }
        };
        this.ws.onopen = () => {
            this.D('Web Socket Opened...');
            this.headers['accept-version'] = VERSIONS.supportedVersions;
            this.headers['heart-beat'] = [this.heartbeat.outgoing, this.heartbeat.incoming].join(',');
            this._transmit('CONNECT', this.headers);
        };
    }
    disconnect(disconnectCallback, headers) {
        this.D('disconnect, ws.readyState:', this.ws.readyState);
        this._transmit('DISCONNECT', headers || {});
        this.ws.onclose = null;
        this.ws.close();
        this._cleanUp();
        if (disconnectCallback) {
            disconnectCallback();
        }
    }
    _cleanUp() {
        this.connected = false;
        if (this.pinger) {
            clearInterval(this.pinger);
        }
        if (this.ponger) {
            return clearInterval(this.ponger);
        }
    }
    send(destination, headers, body) {
        if (headers == null) {
            headers = {};
        }
        if (body == null) {
            body = '';
        }
        headers.destination = destination;
        return this._transmit('SEND', headers, body);
    }
    subscribe(destination, callback, headers) {
        if (headers == null) {
            headers = {};
        }
        if (!headers.id) {
            headers.id = 'sub-' + this.counter++;
        }
        headers.destination = destination;
        this.subscriptions[headers.id] = callback;
        this._transmit('SUBSCRIBE', headers);
        return {
            id: headers.id,
            unsubscribe: () => this.unsubscribe(headers.id)
        };
    }
    unsubscribe(id) {
        delete this.subscriptions[id];
        this._transmit('UNSUBSCRIBE', { id });
    }
    begin(transaction) {
        const txid = transaction || 'tx-' + this.counter++;
        this._transmit('BEGIN', {
            transaction: txid
        });
        return {
            id: txid,
            commit: () => this.commit(txid),
            abort: () => this.abort(txid)
        };
    }
    commit(transaction) {
        return this._transmit('COMMIT', { transaction });
    }
    abort(transaction) {
        this._transmit('ABORT', { transaction });
    }
    ack(messageID, subscription, headers) {
        if (headers == null) {
            headers = {};
        }
        headers['message-id'] = messageID;
        headers.subscription = subscription;
        return this._transmit('ACK', headers);
    }
    nack(messageID, subscription, headers) {
        if (headers == null) {
            headers = {};
        }
        headers['message-id'] = messageID;
        headers.subscription = subscription;
        return this._transmit('NACK', headers);
    }
}

var DmStompState;
(function (DmStompState) {
    DmStompState[DmStompState["Undefined"] = 0] = "Undefined";
    DmStompState[DmStompState["Connecting"] = 1] = "Connecting";
    DmStompState[DmStompState["Connected"] = 2] = "Connected";
    DmStompState[DmStompState["Disconnecting"] = 3] = "Disconnecting";
    DmStompState[DmStompState["Disconnected"] = 4] = "Disconnected";
})(DmStompState || (DmStompState = {}));
class DmStompServiceConfig {
    constructor() {
        this.url = '';
        this.login = 'guest';
        this.passcode = 'guest';
        this.heartbeatIn = 0;
        this.heartbeatOut = 20000;
        this.host = '/';
        this.protocols = ['v10.stomp', 'v11.stomp'];
    }
}
class StompQ {
    static client(url, protocols) {
        if (protocols == null) {
            protocols = ['v10.stomp', 'v11.stomp'];
        }
        const ws = new WebSocket(url, protocols);
        return new StompClient(ws);
    }
    static over(ws) {
        return new StompClient(ws);
    }
    static D(...args) {
        if (this.debug) {
            this.debug(...args);
        }
    }
}
class DmStompService {
    constructor(config) {
        this.config = config;
        this._state = DmStompState.Undefined;
        this.state = new BehaviorSubject(DmStompState.Undefined);
        this.onError = new Subject();
        this.onConnect = new Subject();
        this.onDisconnect = new Subject();
        this.onReceive = new Subject();
        this.onReceipt = new Subject();
        this.debug = new Subject();
        if (config) {
            this.configure(config);
        }
    }
    configure(config) {
        this.config = config;
        const ws = this.config.ws || new WebSocket(this.config.url, this.config.protocols);
        this.client = new StompClient(ws);
        this.client.heartbeat.incoming = this.config.heartbeatIn;
        this.client.heartbeat.outgoing = this.config.heartbeatOut;
        this.client.errorCallback = f => this.onError.next(f);
        this.client.connectCallback = f => this.onConnect.next(f);
        this.client.disconnectCallback = f => this.onDisconnect.next(f);
        this.client.onreceive = f => this.onReceive.next(f);
        this.client.onreceipt = f => this.onReceipt.next(f);
    }
    connect() {
        if ((this._state != DmStompState.Undefined && this._state != DmStompState.Disconnected)
            || !this.client
            || !this.config) {
            return false;
        }
        this.state.next(DmStompState.Connecting);
        this.client.connect(this.config.login, this.config.passcode, this.config.host);
        return true;
    }
    disconnect(headers) {
        this.state.next(DmStompState.Disconnecting);
        this.client.disconnect(() => this.state.next(DmStompState.Disconnected), headers);
    }
    publish(topic, message, headers) {
        this.client.send(topic, headers || {}, message);
    }
    subscribe(topic, callback, headers) {
        this.client.subscribe(topic, (msg) => callback(msg), headers || { ack: 'auto' });
    }
    isConnected() {
        return this.client ? this.client.connected : false;
    }
}

export { DmStompService, DmStompServiceConfig, DmStompState, StompClient, StompFrame, StompQ };
//# sourceMappingURL=stomp.js.map
